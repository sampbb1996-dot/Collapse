<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Initiation Threshold — Canonical (Only Window Adapts)</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;          /* outside field */
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas { display: block; }

  /* minimal audio button (disappears after enabling) */
  #audioBtn {
    position: fixed;
    right: 10px;
    bottom: 10px;
    padding: 6px 10px;
    font-size: 12px;
    background: #0c0c0c;
    color: #6a6a6a;
    border: 1px solid #1a1a1a;
    border-radius: 8px;
    opacity: 0.28;
    user-select: none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<button id="audioBtn">audio</button>

<script>
/* =========================================================
   CANONICAL RULES
   - Only adaptive variable: reaction window length (WINDOW_MS)
   - Cadence, jitter, visuals, audio behavior are FIXED
   - No explicit feedback
   - A/V are intentionally slightly misaligned (small drifting margin)
========================================================= */

/* -------------------------
   PERSISTENCE (ONLY WINDOW_MS)
-------------------------- */
const STORAGE_KEY = "initiation_window_state_v2";

function loadState() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || "null"); }
  catch { return null; }
}
function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({
    WINDOW_MS,
    savedAt: Date.now()
  }));
}

/* -------------------------
   TIMING (FIXED except WINDOW_MS)
-------------------------- */
let WINDOW_MS = 520;            // adaptive reaction window (ms) — ONLY adapting knob
const GAP_MS = 1400;            // fixed gap between events (ms)
const JITTER_MS = 40;           // fixed slight jitter (ms) — NOT adaptive

const MIN_WINDOW = 260;
const MAX_WINDOW = 900;
const STEP = 20;

const HIT_THRESHOLD = 7;
const MISS_THRESHOLD = 4;

/* calm gating controls WHEN adaptation can occur (not what changes) */
const RT_HISTORY = 8;
const MAX_RT_STD = 85;          // ms
const MAX_RECENT_MISSES = 4;

/* day-level carryover: tiny soften only */
const saved = loadState();
if (saved && typeof saved.WINDOW_MS === "number") {
  WINDOW_MS = Math.min(MAX_WINDOW, Math.max(MIN_WINDOW, saved.WINDOW_MS + 10));
}

/* -------------------------
   CANVAS / FIELD (1:1)
-------------------------- */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: false });

let W = 0, H = 0;
let field = { x: 0, y: 0, s: 0 };

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  const s = Math.floor(Math.min(W, H) * 0.86);  // 1:1 field size
  field.s = s;
  field.x = Math.floor((W - s) / 2);
  field.y = Math.floor((H - s) / 2);
}
addEventListener("resize", resize);
resize();

/* -------------------------
   AUDIO (OPTIONAL / QUIET + slight A/V margin)
-------------------------- */
let audioCtx, noiseNode, gainNode;
let audioOn = false;

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // White noise buffer (1 second loop)
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;

  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = buffer;
  noiseNode.loop = true;

  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0.0; // start silent

  noiseNode.connect(gainNode).connect(audioCtx.destination);
  noiseNode.start();
}

document.getElementById("audioBtn").onclick = async () => {
  if (!audioOn) {
    initAudio();
    audioOn = true;
    document.getElementById("audioBtn").remove();
  }
};

/* -------------------------
   STATE (NO FEEDBACK)
-------------------------- */
let active = false;
let tStart = 0;
let tapRegistered = false;

let hitCount = 0;
let missCount = 0;

let rtHistory = [];
let recentMisses = 0;

/* -------------------------
   CALM GATING HELPERS
-------------------------- */
function stdDev(arr) {
  const mean = arr.reduce((a,b)=>a+b,0) / arr.length;
  const v = arr.reduce((a,b)=>a + (b-mean)**2,0) / arr.length;
  return Math.sqrt(v);
}

function canAdaptNow() {
  if (rtHistory.length < RT_HISTORY) return false;
  if (recentMisses > MAX_RECENT_MISSES) return false;
  if (stdDev(rtHistory) > MAX_RT_STD) return false;
  return true;
}

function clampWindow() {
  WINDOW_MS = Math.min(MAX_WINDOW, Math.max(MIN_WINDOW, WINDOW_MS));
}

/* -------------------------
   INPUT
-------------------------- */
document.body.addEventListener("pointerdown", () => {
  if (!active) return;          // taps outside window ignored
  if (tapRegistered) return;    // one action only

  tapRegistered = true;
  const rt = performance.now() - tStart;

  rtHistory.push(rt);
  if (rtHistory.length > RT_HISTORY) rtHistory.shift();

  hitCount++;
  missCount = 0;
  recentMisses = Math.max(0, recentMisses - 1);

  // tighten only when calm
  if (canAdaptNow() && hitCount >= HIT_THRESHOLD) {
    WINDOW_MS -= STEP;
    clampWindow();
    hitCount = 0;
    saveState();
  }

  endEvent();
});

/* -------------------------
   LOOP (FIXED CADENCE)
-------------------------- */
function jitter(ms) {
  return ms + (Math.random() * 2 - 1) * JITTER_MS;
}

let eventTimeout = null;
let gapTimeout = null;

function startEvent() {
  active = true;
  tapRegistered = false;
  tStart = performance.now();

  eventTimeout = setTimeout(() => {
    if (!tapRegistered) {
      active = false;
      missCount++;
      hitCount = 0;
      recentMisses++;

      // loosen only when calm
      if (canAdaptNow() && missCount >= MISS_THRESHOLD) {
        WINDOW_MS += STEP;
        clampWindow();
        missCount = 0;
        saveState();
      }
    }
    endEvent();
  }, jitter(WINDOW_MS));
}

function endEvent() {
  active = false;
  clearTimeout(eventTimeout);

  clearTimeout(gapTimeout);
  gapTimeout = setTimeout(startEvent, jitter(GAP_MS));
}

// start after a short settle
setTimeout(startEvent, 900);

/* -------------------------
   RENDER (ABSTRACT / FULL-LENGTH LINE / FADE-TO-INFINITY / DEGNERATE DRIFT)
   - Field: near-black square
   - Line: off-white, ultra-faint, FULL-LENGTH through field
   - Event: envelope boosts alpha+width, then exponential decay back to baseline
   - Degenerate "spiral" = sub-perceptual tilt drift
   - Audio envelope is slightly misaligned vs visual (small drifting lead/lag)
-------------------------- */
const nearBlack = "#070707";          // field background (near-black, not pure)
const offWhiteRGB = [235, 235, 230];  // off-white (night-shift friendly)

const baseAlpha = 0.028;
const baseWidth = 0.65;

const peakAlpha = 0.095;
const peakWidth = 2.1;

function expDecay01(elapsed, duration) {
  const k = 4.2; // fixed
  const x = Math.max(0, Math.min(1, elapsed / duration));
  return Math.exp(-k * x);
}

/* fixed A/V margin: small, slowly drifting, sometimes audio leads or lags */
function avOffsetMs(nowMs) {
  // +/- ~35ms max, very slow drift; fixed behavior (not adaptive)
  const t = nowMs / 1000;
  return 35 * Math.sin(t / 19) + 12 * Math.sin(t / 61);
}

/* map envelope to audio gain (quiet) */
function setAudioGainFromEnvelope(d) {
  if (!audioOn || !gainNode) return;
  // extremely quiet, with small lift during event
  const g = 0.006 + 0.014 * d;  // peak ~0.02 (quiet)
  gainNode.gain.value = g;
}

function draw() {
  const now = performance.now();

  // outside background
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, W, H);

  // field background
  ctx.fillStyle = nearBlack;
  ctx.fillRect(field.x, field.y, field.s, field.s);

  // visual envelope
  let a = baseAlpha;
  let w = baseWidth;

  if (active) {
    const elapsedV = now - tStart;
    const dV = expDecay01(elapsedV, WINDOW_MS);

    a = baseAlpha + (peakAlpha - baseAlpha) * dV;
    w = baseWidth + (peakWidth - baseWidth) * dV;

    // audio envelope uses a slightly shifted time (fixed drifting margin)
    const elapsedA = (now + avOffsetMs(now)) - tStart;
    const dA = expDecay01(Math.max(0, elapsedA), WINDOW_MS);
    setAudioGainFromEnvelope(dA);
  } else {
    if (audioOn && gainNode) gainNode.gain.value = 0.0;
  }

  // degenerate drift: tiny, ultra-slow tilt
  const t = now / 1000;
  const tilt = 0.012 * Math.sin(t / 35); // ~0.7° max

  // FULL-LENGTH line through the field (edge to edge, with rounding)
  const cx = field.x + field.s * 0.5;
  const cy = field.y + field.s * 0.5;

  // direction vector from tilt: near-vertical baseline
  const dx = Math.sin(tilt);
  const dy = Math.cos(tilt);

  // extend beyond field so it always reaches edges even with rounding/tilt
  const len = field.s * 1.45;

  const x1 = cx - dx * (len / 2);
  const y1 = cy - dy * (len / 2);
  const x2 = cx + dx * (len / 2);
  const y2 = cy + dy * (len / 2);

  ctx.save();
  ctx.lineCap = "round";
  ctx.lineWidth = w;
  ctx.strokeStyle = `rgba(${offWhiteRGB[0]},${offWhiteRGB[1]},${offWhiteRGB[2]},${a})`;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  ctx.restore();

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
