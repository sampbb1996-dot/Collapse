<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Centered Field (Tilt Drift)</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas { display: block; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<script>
/* =========================
   CANVAS (single DPR strategy)
========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let dpr = 1, vw = 0, vh = 0;

function resize() {
  vw = window.innerWidth;
  vh = window.innerHeight;
  dpr = window.devicePixelRatio || 1;

  canvas.width = Math.floor(vw * dpr);
  canvas.height = Math.floor(vh * dpr);
  canvas.style.width = vw + "px";
  canvas.style.height = vh + "px";

  // draw in CSS pixels
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
addEventListener("resize", resize);
resize();

/* =========================
   VISUAL CONSTANTS
========================= */
const FG = [235, 235, 235];          // off-white
const BASE_WIDTH = 10;               // base line width
const MAX_ALPHA = 0.85;              // center alpha
const TRACK_ALPHA = 0.08;            // faint track

// "fade to infinity" feel: long line + ends to ~0
const LINE_LEN = 1.25;               // multiplier of screen height

/* =========================
   SUB-PERCEPTUAL TILT DRIFT
   - bounded random walk with mean reversion
   - does NOT create a visible "rotation task"
========================= */
let theta = 0;                        // radians
const THETA_MAX = (0.9 * Math.PI) / 180;  // ±0.9° (small)
const THETA_DRIFT = 0.00008;          // random walk speed
const THETA_RELAX = 0.00006;          // pull back to 0

let lastT = performance.now();

/* =========================
   HELPERS
========================= */
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

/* =========================
   RENDER
========================= */
function draw(now) {
  const dt = Math.min(50, now - lastT); // ms cap
  lastT = now;

  // --- update tilt (sub-perceptual) ---
  // random walk + mean reversion
  theta += (Math.random() - 0.5) * THETA_DRIFT * dt;
  theta += (0 - theta) * THETA_RELAX * dt;
  theta = clamp(theta, -THETA_MAX, THETA_MAX);

  // --- clear background (fixed) ---
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, vw, vh);

  // --- geometry ---
  const cx = vw / 2;
  const cy = vh / 2;

  const halfLen = (vh * LINE_LEN) / 2;

  // endpoints of the tilted line
  const dx = Math.sin(theta) * halfLen;
  const dy = Math.cos(theta) * halfLen;

  const x1 = cx - dx, y1 = cy - dy;
  const x2 = cx + dx, y2 = cy + dy;

  // faint track (same axis, lower alpha)
  ctx.lineCap = "round";
  ctx.lineWidth = BASE_WIDTH;
  ctx.strokeStyle = `rgba(${FG[0]},${FG[1]},${FG[2]},${TRACK_ALPHA})`;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  // "fade to infinity": alpha peaks at center, decays toward ends
  const grad = ctx.createLinearGradient(x1, y1, x2, y2);
  grad.addColorStop(0.00, `rgba(${FG[0]},${FG[1]},${FG[2]},0.0)`);
  grad.addColorStop(0.18, `rgba(${FG[0]},${FG[1]},${FG[2]},${0.22 * MAX_ALPHA})`);
  grad.addColorStop(0.50, `rgba(${FG[0]},${FG[1]},${FG[2]},${1.00 * MAX_ALPHA})`);
  grad.addColorStop(0.82, `rgba(${FG[0]},${FG[1]},${FG[2]},${0.22 * MAX_ALPHA})`);
  grad.addColorStop(1.00, `rgba(${FG[0]},${FG[1]},${FG[2]},0.0)`);

  // slight width emphasis at center without a "pulse"
  ctx.strokeStyle = grad;
  ctx.lineWidth = BASE_WIDTH * 1.05;

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
</script>

</body>
</html>
