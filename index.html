<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
  content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Signal</title>

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: #000;
  overflow: hidden;

  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
}
canvas { position: fixed; inset: 0; display: block; }
#overlay{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  font-family:system-ui; font-size:18px; color:#777;
  background:transparent;
}
#overlay.hidden{ opacity:0; pointer-events:none; }
</style>
</head>

<body>
<canvas id="c"></canvas>
<div id="overlay">touch and hold to begin</div>

<script>
/* =========================
   AUDIO — iOS-RELIABLE UNLOCK
   Inverted control:
   HOLD = mute, RELEASE = restore
========================= */

let audioCtx, noiseSource, gainNode;
let audioStarted = false;

let targetGain = 0.04;        // audible baseline (adjust later)
const RESTORE_GAIN = 0.04;    // on release
const MUTE_GAIN = 0.0;        // on hold

function setGainTarget(g){ targetGain = g; }

function smoothGain(){
  if (!gainNode) return;
  gainNode.gain.value += (targetGain - gainNode.gain.value) * 0.03;
}

async function startAudioFromGesture(){
  if (audioStarted) return;
  audioStarted = true;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // MUST be awaited on iOS
  try { await audioCtx.resume(); } catch (_) {}

  // iOS "route unlock": tiny oscillator burst (near-silent)
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    g.gain.value = 0.0001;
    o.connect(g).connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + 0.01);
  } catch (_) {}

  // Build looping noise buffer
  const size = audioCtx.sampleRate * 2;
  const buffer = audioCtx.createBuffer(1, size, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < size; i++) data[i] = Math.random() * 2 - 1;

  noiseSource = audioCtx.createBufferSource();
  noiseSource.buffer = buffer;
  noiseSource.loop = true;

  gainNode = audioCtx.createGain();
  gainNode.gain.value = RESTORE_GAIN;

  noiseSource.connect(gainNode).connect(audioCtx.destination);
  noiseSource.start();
}

/* =========================
   CANVAS — FULL FIELD, NO GEOMETRY
========================= */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: false });

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

// very-dark baseline so "darkening" is meaningful
const base = 7;

function fillBase(){
  ctx.fillStyle = `rgb(${base},${base},${base})`;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

function sprinkle(){
  // density tuned to avoid banding/bars from scaling
  const n = Math.floor((canvas.width * canvas.height) / 2000);

  // subtractive (inverted) marks
  ctx.fillStyle = "rgba(0,0,0,0.06)";
  for (let i = 0; i < n; i++){
    const x = (Math.random() * canvas.width) | 0;
    const y = (Math.random() * canvas.height) | 0;
    ctx.fillRect(x, y, 2, 2);
  }

  // tiny compensating brighten so it doesn't collapse to flat black
  ctx.fillStyle = "rgba(255,255,255,0.004)";
  for (let i = 0; i < (n * 0.25); i++){
    const x = (Math.random() * canvas.width) | 0;
    const y = (Math.random() * canvas.height) | 0;
    ctx.fillRect(x, y, 1, 1);
  }
}

function draw(){
  // hard fill prevents iOS white flash
  fillBase();
  sprinkle();

  smoothGain();

  requestAnimationFrame(draw);
}

/* =========================
   INPUT — INVERTED
   ACTION = RELEASE
========================= */

const overlay = document.getElementById("overlay");
let started = false;
let holding = false;

// Start visual + audio on the most iOS-safe gesture: UP / END
async function beginFromUp(e){
  if (started) return;
  started = true;

  e.preventDefault();
  e.stopPropagation();

  requestAnimationFrame(draw);

  await startAudioFromGesture();

  overlay.classList.add("hidden");
  document.body.offsetHeight;
}

// HOLD: mute
function onDown(e){
  holding = true;
  setGainTarget(MUTE_GAIN);
}

// RELEASE: action + restore
function onUp(e){
  if (!started) {
    // First ever release starts everything (iOS-safe)
    beginFromUp(e);
  } else {
    e.preventDefault();
    e.stopPropagation();
  }
  holding = false;
  setGainTarget(RESTORE_GAIN);

  // ACTION hook point (release = commit)
  // const t = performance.now();
}

// Bind (use both pointer + touch for iOS reliability)
window.addEventListener("pointerdown", onDown, { passive:false });
window.addEventListener("pointerup", onUp, { passive:false });
window.addEventListener("touchstart", onDown, { passive:false });
window.addEventListener("touchend", onUp, { passive:false });
</script>
</body>
</html>
