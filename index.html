<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>3 Modes</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      touch-action: manipulation;
      user-select: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #777;
    }

    #hud {
      position: fixed;
      top: 16px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 16px;
      pointer-events: none;
    }

    #stage {
      position: fixed;
      inset: 0;
    }

    /* binary presence only: visible or not */
    #obj {
      position: fixed;
      left: 50%;
      top: 45%;
      transform: translate(-50%, -50%);
      width: 92px;
      height: 92px;
      background: #fff;
      border-radius: 18px;
      display: block; /* starts at steady A */
    }

    #controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 22px;
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 0 14px;
    }

    button {
      border: 0;
      border-radius: 999px;
      padding: 14px 18px;
      font-size: 15px;
      background: #222;
      color: #eee;
    }
    button.active { background: #444; }
  </style>
</head>
<body>
  <div id="hud">mode: game</div>
  <div id="stage"></div>
  <div id="obj"></div>

  <div id="controls">
    <button id="mGame" class="active">game</button>
    <button id="mSlide">slideshow</button>
    <button id="mAuto">autoplay</button>
    <button id="reset">reset</button>
  </div>

<script>
(() => {
  // Modes:
  // 0 game     : auto ticks, tap = binary (left/right) + advances one step immediately
  // 1 slideshow: no auto ticks, tap = advance only (no binary, no inference)
  // 2 autoplay : auto ticks, taps ignored (pure viewing)
  let mode = 0;

  // ---- core state ----
  // "A state" = steady visible.
  // System can be pushed away from A by "coherent" (intentional) input.
  let S = 0;                  // latent drift (returns to 0)
  let C = 0;                  // confidence in intention (0..1)
  let pHat = 0.5;             // estimated bias of user's binary (0..1)

  // fixed time
  const TICK_MS = 1000;

  // dynamics
  const RETURN = 0.06;        // pull back toward A each tick
  const WANDER = 0.22;        // how far from A the system can drift when C is high
  const INFER_RATE = 0.08;    // how fast we adapt pHat
  const C_UP = 0.06;          // increase confidence on coherence
  const C_DOWN = 0.10;        // decrease confidence on incoherence

  // rendering threshold
  const ABSENT_CUTOFF = 0.55; // higher = more often present

  const hud = document.getElementById("hud");
  const obj = document.getElementById("obj");

  const bGame = document.getElementById("mGame");
  const bSlide = document.getElementById("mSlide");
  const bAuto = document.getElementById("mAuto");
  const bReset = document.getElementById("reset");

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

  function setMode(m){
    mode = m;
    bGame.classList.toggle("active", mode === 0);
    bSlide.classList.toggle("active", mode === 1);
    bAuto.classList.toggle("active", mode === 2);
    hud.textContent = `mode: ${mode===0?"game":mode===1?"slideshow":"autoplay"}`;
  }

  // ---- intention inference (game mode only) ----
  // "Coherence" is self-consistency relative to the running estimate pHat.
  // Random tapping tends to pHat ~ 0.5 and produces low predictability => C decays back toward 0.
  function ingestBit(bit){
    // bit in {0,1}
    const pred = (pHat >= 0.5) ? 1 : 0;
    const coherent = (bit === pred);

    // update confidence (no feedback shown)
    C = clamp01(C + (coherent ? C_UP : -C_DOWN));

    // update estimated bias
    pHat = (1 - INFER_RATE) * pHat + INFER_RATE * bit;

    // push latent state away from A only if confidence exists
    // (coherent input increases ability to move system forward; incoherent input dampens)
    const dir = bit ? 1 : -1;
    S += dir * (0.10 + 0.25 * C);
    S = clamp(S, -2.5, 2.5);
  }

  // ---- tick evolution ----
  function step(){
    // return toward A regardless of input
    S *= (1 - RETURN);

    // when intention confidence is low, system collapses toward A (steady presence)
    // when high, system wanders (variance) away from A
    if (C > 0.01) {
      const noise = (Math.random() * 2 - 1) * (WANDER * C);
      S = clamp(S + noise, -2.5, 2.5);
    }

    // render: present/not present only
    // A state => always present
    if (C < 0.10 && Math.abs(S) < 0.25) {
      obj.style.display = "block";
      return;
    }

    // otherwise presence becomes contingent on state
    // higher C increases the chance of "not-A" (absence) appearing.
    const absenceBias = clamp01((Math.abs(S) / 2.5) * (0.35 + 0.65 * C));
    const presentProb = clamp01(1 - absenceBias);

    obj.style.display = (Math.random() < presentProb && presentProb > (1 - ABSENT_CUTOFF)) ? "block" : "none";
  }

  // ---- timing ----
  setInterval(() => {
    if (mode === 0 || mode === 2) step(); // game and autoplay are fixed-interval
  }, TICK_MS);

  // ---- input surface ----
  // In game mode:
  //   tap left/right = 0/1 + immediate step
  // In slideshow:
  //   tap = immediate step only
  // In autoplay:
  //   taps ignored
  document.body.addEventListener("pointerdown", (e) => {
    if (e.target && e.target.tagName === "BUTTON") return;

    if (mode === 0) {
      const x = e.clientX / window.innerWidth;
      const bit = (x < 0.5) ? 0 : 1;     // binary from tap position
      ingestBit(bit);
      step();                             // immediate advance (required)
      return;
    }

    if (mode === 1) {
      step();                             // advance only
      return;
    }

    // mode === 2: ignore
  });

  // ---- controls ----
  bGame.onclick = () => setMode(0);
  bSlide.onclick = () => setMode(1);
  bAuto.onclick = () => setMode(2);

  bReset.onclick = (e) => {
    e.stopPropagation();
    S = 0;
    C = 0;
    pHat = 0.5;
    obj.style.display = "block"; // steady A
  };

  // init
  setMode(0);
  obj.style.display = "block"; // steady A at start
})();
</script>
</body>
</html>
