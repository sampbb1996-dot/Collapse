<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Field</title>

<style>
html, body, canvas {
  margin: 0;
  padding: 0;
  background: #000;
  overflow: hidden;

  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  touch-action: none;
}
canvas { display: block; }

#hint {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: rgba(255,255,255,0.28);
  font-family: system-ui, sans-serif;
  font-size: 18px;
  pointer-events: none;
}
</style>
</head>

<body>
<canvas id="c"></canvas>
<div id="hint">touch and hold</div>

<script>
/* =========================
   HARD BLOCK SAFARI UI
========================= */
document.addEventListener("contextmenu", e => e.preventDefault(), { passive: false });
document.addEventListener("selectstart", e => e.preventDefault(), { passive: false });

/* =========================
   INVERSION STACK
========================= */
const invert = true;
const metaInvert = true;
const effectiveInvert = () => invert !== metaInvert; // XOR

/* =========================
   STATE
========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w = 0, h = 0;
let running = false;
let pressure = 0.5;

// Φ latent state
let latent = null;
let handed = 0;

/* =========================
   RESIZE
========================= */
function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* =========================
   AUDIO GRAPH (iOS SAFE)
========================= */
let audioCtx = null;
let noise = null;

// nodes
let gain = null;
let panner = null;
let lowShelf = null;
let highShelf = null;
let presence = null;
let bandpass = null;
let compressor = null;

function initAudio() {
  if (audioCtx) return;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // noise source
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
  const ch = buffer.getChannelData(0);
  for (let i = 0; i < ch.length; i++) ch[i] = Math.random() * 2 - 1;

  noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  noise.loop = true;

  // nodes
  gain = audioCtx.createGain();
  gain.gain.value = 0;

  panner = audioCtx.createStereoPanner();
  panner.pan.value = 0;

  lowShelf = audioCtx.createBiquadFilter();
  lowShelf.type = "lowshelf";
  lowShelf.frequency.value = 180; // bass region
  lowShelf.gain.value = 0;

  highShelf = audioCtx.createBiquadFilter();
  highShelf.type = "highshelf";
  highShelf.frequency.value = 3500; // treble region
  highShelf.gain.value = 0;

  presence = audioCtx.createBiquadFilter();
  presence.type = "peaking";
  presence.frequency.value = 1200;
  presence.Q.value = 1.0;
  presence.gain.value = 0;

  bandpass = audioCtx.createBiquadFilter();
  bandpass.type = "bandpass";
  bandpass.frequency.value = 900;
  bandpass.Q.value = 0.7;

  compressor = audioCtx.createDynamicsCompressor();
  compressor.threshold.value = -24;
  compressor.knee.value = 12;
  compressor.ratio.value = 1.2;
  compressor.attack.value = 0.01;
  compressor.release.value = 0.15;

  // connect graph
  noise
    .connect(lowShelf)
    .connect(highShelf)
    .connect(presence)
    .connect(bandpass)
    .connect(compressor)
    .connect(gain)
    .connect(panner)
    .connect(audioCtx.destination);

  noise.start();
}

function resumeAudio() {
  if (audioCtx && audioCtx.state !== "running") audioCtx.resume();
}

/* =========================
   INPUT
========================= */
function readPressure(e) {
  let p = 0.5;
  if (e.pressure && e.pressure > 0) p = e.pressure;
  pressure = Math.max(0, Math.min(1, p));
}

function startHold(e) {
  e.preventDefault();
  running = true;

  initAudio();
  resumeAudio();

  document.getElementById("hint").style.display = "none";
  readPressure(e);
}

function moveHold(e) {
  e.preventDefault();
  if (running) readPressure(e);
}

function endHold(e) {
  e.preventDefault();
  running = false;

  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, w, h);

  // silence + reset
  if (gain) gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02);
  if (panner) panner.pan.setTargetAtTime(0, audioCtx.currentTime, 0.02);

  latent = null;
  handed = 0;

  document.getElementById("hint").style.display = "flex";
}

canvas.addEventListener("pointerdown", startHold, { passive: false });
canvas.addEventListener("pointermove", moveHold, { passive: false });
canvas.addEventListener("pointerup", endHold, { passive: false });
canvas.addEventListener("pointercancel", endHold, { passive: false });

/* =========================
   CONTROL (SUBTRACTIVE)
========================= */
function controlU() {
  const inv = effectiveInvert();
  const u = inv ? (1 - pressure) : pressure;
  return Math.max(0, Math.min(1, u));
}

function collapse(u, floor, range) {
  return floor + range * (1 - u);
}

/* =========================
   Φ-STYLE BIOMECH COLLAPSE
========================= */
function biomechU(u) {
  if (latent === null) {
    latent = u;
    handed = 0;
    return latent;
  }

  const delta = u - latent;
  const mag = Math.abs(delta);
  const pivot = 0.06;

  if (mag > pivot) handed = Math.sign(delta);

  const bias = 0.92 + (0.06 * (1 - Math.min(1, mag / 0.25)));
  const jitter = (mag > pivot) ? (Math.random() - 0.5) * (0.02 * Math.min(1, mag / 0.25)) : 0;
  const dir = (handed !== 0 && mag > pivot)
    ? handed * (Math.random() * (0.01 * Math.min(1, mag / 0.25)))
    : 0;

  latent = bias * latent + (1 - bias) * u + jitter + dir;
  latent = Math.max(0, Math.min(1, latent));
  return latent;
}

/* =========================
   LOOP
========================= */
function step() {
  requestAnimationFrame(step);
  if (!running) return;

  // visual invariant black
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, w, h);

  const u = controlU();
  const ub = biomechU(u);

  // --- AUDIO MAPPING (ALL SUBTRACTIVE) ---

  // amplitude
  gain.gain.setTargetAtTime(
    collapse(ub, 0.01, 0.045),
    audioCtx.currentTime,
    0.03
  );

  // panning (subtle, noisy, non-confirmable)
  panner.pan.setTargetAtTime(
    handed * collapse(ub, 0.0, 0.35),
    audioCtx.currentTime,
    0.05
  );

  // bass / treble tilt (attenuation only)
  lowShelf.gain.setTargetAtTime(
    -collapse(ub, 0, 8), // up to -8 dB under force
    audioCtx.currentTime,
    0.08
  );
  highShelf.gain.setTargetAtTime(
    -collapse(ub, 0, 6), // up to -6 dB under force
    audioCtx.currentTime,
    0.08
  );

  // presence attenuation
  presence.gain.setTargetAtTime(
    -collapse(ub, 0, 5),
    audioCtx.currentTime,
    0.08
  );

  // bandwidth tightening
  bandpass.Q.setTargetAtTime(
    collapse(ub, 0.7, 4.0), // higher Q = narrower band
    audioCtx.currentTime,
    0.08
  );

  // dynamics punishment
  compressor.ratio.setTargetAtTime(
    collapse(ub, 1.2, 4.0), // more compression under force
    audioCtx.currentTime,
    0.1
  );
}

step();
</script>
</body>
</html>
