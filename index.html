# scanner.py
# Final form: AGNOSTICISM AS TERMINAL LAYER
#
# Meaningless observation.
# Frame-relative comparison allowed internally.
# No belief, no preference, no optimization, no narrative.
# Action is accidental; stability governs existence.

from __future__ import annotations
import time
import statistics
from dataclasses import dataclass, field
from typing import Iterable, Optional, List


# =========================
# INVARIANTS (NON-NEGOTIABLE)
# =========================

SCAN_INTERVAL_S = 180

MISPRICE_RATIO = 0.60

STABILITY_BUF = 18
STABILITY_MIN_N = 6
STABILITY_RELSTD_MAX = 0.22

FREEZE_S = 300


# =========================
# DATA
# =========================

@dataclass(frozen=True)
class Listing:
    listing_id: str
    price: float


@dataclass
class State:
    ratios: List[float] = field(default_factory=list)
    frozen_until: float = 0.0
    acted: set = field(default_factory=set)


STATE = State()


# =========================
# OBSERVATION (REPLACE ONLY)
# =========================

def fetch_listings() -> Iterable[Listing]:
    return [
        Listing("x1", 40.0),
    ]


def sold_anchor(listing: Listing) -> Optional[float]:
    return 120.0


# =========================
# AGNOSTIC CORE
# =========================

def push_ratio(r: float):
    STATE.ratios.append(r)
    if len(STATE.ratios) > STABILITY_BUF:
        STATE.ratios.pop(0)


def stable() -> bool:
    if len(STATE.ratios) < STABILITY_MIN_N:
        return False
    mean = statistics.fmean(STATE.ratios)
    if mean <= 0:
        return False
    relstd = statistics.pstdev(STATE.ratios) / mean
    return relstd <= STABILITY_RELSTD_MAX


def freeze(now: float):
    STATE.frozen_until = now + FREEZE_S


def frozen(now: float) -> bool:
    return now < STATE.frozen_until


def mispriced(ask: float, anchor: float) -> bool:
    return ask <= MISPRICE_RATIO * anchor


# =========================
# ACTION (NON-SIGNIFYING)
# =========================

def act(listing: Listing):
    # No success, no failure, no continuation bias
    print(f"ACT {listing.listing_id} @ {listing.price}")
    STATE.acted.add(listing.listing_id)


# =========================
# LOOP
# =========================

def run():
    while True:
        now = time.time()

        if frozen(now):
            time.sleep(SCAN_INTERVAL_S)
            continue

        listings = list(fetch_listings())
        observed = False

        for listing in listings:
            if listing.listing_id in STATE.acted:
                continue

            anchor = sold_anchor(listing)
            if not anchor:
                continue

            ratio = listing.price / anchor
            push_ratio(ratio)
            observed = True

            if not stable():
                continue

            if mispriced(listing.price, anchor):
                act(listing)
                break

        if observed and not stable():
            freeze(now)

        time.sleep(SCAN_INTERVAL_S)


if __name__ == "__main__":
    run()
