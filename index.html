<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, user-scalable=no"
/>
<title>Field</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    touch-action: none;
  }
  canvas { display: block; }
  #hint {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: rgba(255,255,255,0.30);
    font-family: system-ui, sans-serif;
    font-size: 18px;
    pointer-events: none;
  }
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="hint">touch and hold</div>

<script>
/* ======================
   CONFIG (locked)
====================== */

// Primary inversion (on/off)
let invert = true;

// Meta inversion (inverts the inversion itself)
let metaInvert = true;

// IMPORTANT:
// metaInvert acts on invert (XOR), not on the signal twice.
function effectiveInvert() {
  return invert !== metaInvert; // XOR
}

/* ======================
   STATE
====================== */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w = 0, h = 0;
let running = false;

// pressure in [0,1]
let p = 0.5;

// latent band position state (only exists while touching)
let x = 0;
let vx = 0;

/* ======================
   RESIZE
====================== */

function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize, { passive: false });
resize();

/* ======================
   AUDIO
====================== */

let audioCtx = null;
let noise = null;
let gain = null;

function startAudio() {
  if (audioCtx) return;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // simple looping noise buffer
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
  const ch = buffer.getChannelData(0);
  for (let i = 0; i < ch.length; i++) ch[i] = Math.random() * 2 - 1;

  noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  noise.loop = true;

  gain = audioCtx.createGain();
  gain.gain.value = 0;

  noise.connect(gain).connect(audioCtx.destination);
  noise.start();
}

function setAudioLevel(level) {
  if (!gain) return;
  // clamp
  gain.gain.value = Math.max(0, Math.min(0.2, level));
}

/* ======================
   INPUT
====================== */

function readPressureFromTouch(e) {
  // default if device doesn't support force
  let val = 0.5;

  const t = e.touches && e.touches[0];
  if (t && typeof t.force === "number") {
    // iOS often reports 0; keep a small floor to avoid hard-collapse
    const f = t.force === 0 ? 0.05 : t.force;
    val = Math.max(0, Math.min(1, f));
  }

  p = val;
}

canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();

  running = true;
  startAudio();

  const hint = document.getElementById("hint");
  hint.style.display = "none";

  readPressureFromTouch(e);

  // initialize band state on engagement (no observable carry-over)
  x = w * (0.25 + Math.random() * 0.5);
  vx = 0;
}, { passive: false });

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if (!running) return;
  readPressureFromTouch(e);
}, { passive: false });

canvas.addEventListener("touchend", (e) => {
  e.preventDefault();
  running = false;

  // hard-black immediately; cannot observe state
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, w, h);

  // mute immediately
  setAudioLevel(0);

  // show hint again (optional; remove if you want)
  document.getElementById("hint").style.display = "flex";
}, { passive: false });

/* ======================
   CONTROL (subtractive)
====================== */

// Produce a control value u in [0,1], with inversion stack applied
// effectiveInvert() decides whether we use p or (1-p).
function controlU() {
  const inv = effectiveInvert();
  const u = inv ? (1 - p) : p;     // inversion/non-inversion + meta inversion over that
  return Math.max(0, Math.min(1, u));
}

// Subtractive collapse: higher u => lower output
function collapse01(u, floor, range) {
  // output = floor + range*(1-u)
  return floor + range * (1 - u);
}

/* ======================
   RENDER LOOP
====================== */

function step() {
  requestAnimationFrame(step);

  if (!running) return;

  // Always clear to black while touching too (no trails, no accumulation)
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, w, h);

  const u = controlU();

  // --- Visual: faint unstable band (visible without becoming texture) ---
  // Non-periodic micro-instability (random walk)
  vx += (Math.random() - 0.5) * 0.25;
  vx *= 0.985;
  x += vx;

  // wrap (no edges as "event")
  if (x < 0) x += w;
  if (x >= w) x -= w;

  // Subtractive mapping: more u => dimmer band
  const alpha = collapse01(u, 0.03, 0.10); // [0.03..0.13]
  const bw = 1 + Math.floor(Math.random() * 2); // 1â€“2 px, no stable width

  ctx.fillStyle = `rgba(255,255,255,${alpha})`;
  ctx.fillRect(Math.floor(x), 0, bw, h);

  // --- Audio: subtractive + same u ---
  // more u => quieter (punishes force after inversion stack)
  const audioLevel = collapse01(u, 0.015, 0.050); // ~0.015..0.065
  setAudioLevel(audioLevel);
}

step();
</script>
</body>
</html>
