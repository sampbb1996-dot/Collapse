<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Scalar Drift Instrument</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000; /* fixed, do not fade */
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas { display: block; }
  #audioBtn{
    position: fixed;
    bottom: 22px;
    left: 50%;
    transform: translateX(-50%);
    padding: 14px 18px;
    border-radius: 16px;
    border: 1px solid rgba(230,230,230,0.18);
    background: rgba(230,230,230,0.08);
    color: rgba(230,230,230,0.92);
    font-size: 15px;
    backdrop-filter: blur(8px);
  }
</style>
</head>
<body>

<canvas id="c"></canvas>
<button id="audioBtn">Enable Audio</button>

<script>
/* =========================================================
   Instrument: Vertical 1D scalar + hidden binary drift
   - Visual carries information
   - Audio is presence-only
========================================================= */

// --- Tick / latent ---
const TICK_SECONDS = 1.8;

let x = 0.5;          // visible scalar in [0,1]
let p = 0.5;          // P(M)

const MU_M = 0.46;
const MU_F = 0.54;

const MEAN_PULL = 0.14;
const NOISE_AMP = 0.018;

const P_RELAX = 0.002;
const P_JITTER = 0.003;

// --- Carrier drift (bounded, slow, non-rhythmic) ---
let op = 0.44;        // line opacity
let wMul = 1.0;       // width multiplier

const OP_MIN = 0.18;
const OP_MAX = 0.60;

const W_BASE = 12;
const W_MIN = 0.85;
const W_MAX = 1.05;

const OP_DRIFT = 0.0025;
const OP_RELAX = 0.004;

const W_DRIFT  = 0.0018;
const W_RELAX  = 0.004;

// --- Minimal tick acknowledgement (micro, not a beat) ---
let micro = 0;
const MICRO_ADD = 0.10;
const MICRO_DECAY = 0.12;

// --- Colors (off-white foreground) ---
const FG = "rgb(230,230,230)";        // off-white (helps even with Night Shift)
const TRACK_ALPHA = 0.10;             // faint background track
const FILL_ALPHA_BOOST = 0.08;        // micro pulse boost

/* =========================================================
   Canvas
========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  canvas.width = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
addEventListener("resize", resize);
resize();

/* =========================================================
   Audio (presence-only; fixed broadband noise)
========================================================= */
let audioCtx, noiseNode, gainNode;
let audioEnabled = false;

function initAudio(){
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i=0;i<data.length;i++) data[i] = Math.random()*2 - 1;

  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = buffer;
  noiseNode.loop = true;

  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0;

  noiseNode.connect(gainNode).connect(audioCtx.destination);
  noiseNode.start();

  // gentle fade-in to near-threshold bed
  gainNode.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 1.2);
}

document.getElementById("audioBtn").onclick = () => {
  if (!audioEnabled){
    initAudio();
    audioEnabled = true;
    document.getElementById("audioBtn").remove();
  }
};

/* =========================================================
   Utils
========================================================= */
const clamp01 = v => Math.max(0, Math.min(1, v));
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

function randn(){
  let s = 0;
  for (let i=0;i<6;i++) s += Math.random();
  return (s - 3) / 1.22;
}

function roundRect(ctx, x, y, w, h, r){
  r = Math.max(0, Math.min(r, w/2, h/2));
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y,     x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x,     y + h, r);
  ctx.arcTo(x,     y + h, x,     y,     r);
  ctx.arcTo(x,     y,     x + w, y,     r);
  ctx.closePath();
}

/* =========================================================
   Tick update
========================================================= */
let lastTick = performance.now();

function tick(){
  // latent drift
  p += (0.5 - p) * P_RELAX;
  p += (Math.random() - 0.5) * P_JITTER;
  p = clamp01(p);

  // sample hidden state
  const isM = Math.random() < p;
  const mu = isM ? MU_M : MU_F;

  // visible scalar
  x += MEAN_PULL * (mu - x);
  x += NOISE_AMP * randn();
  x = clamp01(x);

  // bounded carrier drift (no rhythm)
  const opMid = (OP_MIN + OP_MAX) / 2;
  op += (Math.random() - 0.5) * OP_DRIFT;
  op += (opMid - op) * OP_RELAX;
  op = clamp(op, OP_MIN, OP_MAX);

  const wMid = (W_MIN + W_MAX) / 2;
  wMul += (Math.random() - 0.5) * W_DRIFT;
  wMul += (wMid - wMul) * W_RELAX;
  wMul = clamp(wMul, W_MIN, W_MAX);

  // micro acknowledgement
  micro = Math.min(1, micro + MICRO_ADD);
}

/* =========================================================
   Render
========================================================= */
function draw(){
  const now = performance.now();
  if (now - lastTick >= TICK_SECONDS * 1000){
    // single tick; keep it simple and stable
    tick();
    lastTick += TICK_SECONDS * 1000;
  }

  micro *= (1 - MICRO_DECAY);

  // fixed background
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, innerWidth, innerHeight);

  // vertical bar geometry
  const barH = innerHeight * 0.65;
  const barTop = (innerHeight - barH) / 2;
  const cx = innerWidth / 2;

  const w = W_BASE * wMul;
  const r = Math.min(w/2, 10);

  // track (faint, off-white)
  ctx.globalAlpha = TRACK_ALPHA;
  ctx.fillStyle = FG;
  roundRect(ctx, cx - w/2, barTop, w, barH, r);
  ctx.fill();

  // filled portion (rounded ends)
  const filledH = barH * x;
  const yFillTop = barTop + (barH - filledH);

  const a = clamp(op + micro * FILL_ALPHA_BOOST, OP_MIN, OP_MAX);
  ctx.globalAlpha = a;
  ctx.fillStyle = FG;
  roundRect(ctx, cx - w/2, yFillTop, w, filledH, r);
  ctx.fill();

  ctx.globalAlpha = 1;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
