<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Initiation Threshold — Symbolic / Speed-Layer Only</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #070707; /* near-black */
    overflow: hidden;
    touch-action: manipulation;
  }

  /* Center a 1:1 field; everything outside stays near-black */
  #wrap {
    position: fixed;
    inset: 0;
    display: grid;
    place-items: center;
  }

  canvas { display: block; }

  /* Minimal audio button: small, low-salience, disappears on enable */
  #audioBtn {
    position: fixed;
    right: 10px;
    bottom: 10px;
    padding: 6px 10px;
    font-size: 12px;
    background: rgba(18,18,18,0.65);
    color: rgba(230,230,230,0.45);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 8px;
    opacity: 0.55;
    user-select: none;
  }
</style>
</head>

<body>
<div id="wrap">
  <canvas id="c"></canvas>
</div>
<button id="audioBtn">audio</button>

<script>
/* =========================================================
   DESIGN CONTRACT (LOCKED)
   - External rhythm (gap/cadence) is fixed.
   - Only one adaptive parameter exists: REACTION_WINDOW_MS.
   - Visual is minimal: faint off-white line inside a centered 1:1 field.
   - The "symbol" is structural only: emergence → fade-to-infinity → absence.
========================================================= */

/* =========================
   FIXED RHYTHM (DO NOT ADAPT)
========================= */
const GAP_MS = 1200;          // fixed inter-trial gap
const START_DELAY_MS = 900;   // fixed start delay

/* =========================
   SPEED-LAYER ONLY (ADAPT THIS)
========================= */
const STORAGE_KEY = "init_threshold_speedlayer_v1";

let REACTION_WINDOW_MS = 1400;     // this is the ONLY adaptive control
const MIN_WINDOW_MS = 850;
const MAX_WINDOW_MS = 1900;

/* Adaptation policy (still speed-layer-only) */
const STEP_MS = 50;
const HITS_TO_TIGHTEN = 5;
const MISSES_TO_LOOSEN = 3;

/* Calm gating (prevents chaotic tightening/loosening) */
const RT_HISTORY = 6;
const MAX_RT_STD_MS = 120;

/* =========================
   RESTORE (OPTIONAL, STILL SPEED-LAYER)
========================= */
(function restore() {
  try {
    const s = JSON.parse(localStorage.getItem(STORAGE_KEY));
    if (!s || typeof s.windowMs !== "number") return;
    // tiny soft reset toward easier each day (still only window changes)
    const softened = s.windowMs + 25;
    REACTION_WINDOW_MS = clamp(softened, MIN_WINDOW_MS, MAX_WINDOW_MS);
  } catch {}
})();

function persist() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      windowMs: REACTION_WINDOW_MS,
      savedAt: Date.now()
    }));
  } catch {}
}

/* =========================
   CANVAS: CENTERED 1:1 FIELD
========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: false });

let side = 0;
function resize() {
  // 1:1 square sized to fit viewport with margin
  const m = 22;
  side = Math.max(180, Math.min(innerWidth, innerHeight) - m * 2);

  canvas.width = Math.floor(side * devicePixelRatio);
  canvas.height = Math.floor(side * devicePixelRatio);
  canvas.style.width = side + "px";
  canvas.style.height = side + "px";

  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  clearField();
}
addEventListener("resize", resize);
resize();

function clearField() {
  // Near-black inside the square (slightly lighter than page background)
  ctx.clearRect(0, 0, side, side);
  ctx.fillStyle = "#0b0b0b";
  ctx.fillRect(0, 0, side, side);
}

/* =========================
   AUDIO (OPTIONAL, LOW-SALIENCE)
   - Pure noise at very low gain.
   - Mapped to the visual alpha (same envelope).
========================= */
let audioCtx, noiseNode, gainNode;
let audioOn = false;

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;

  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = buffer;
  noiseNode.loop = true;

  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0.0; // set by envelope when stimulus runs

  noiseNode.connect(gainNode).connect(audioCtx.destination);
  noiseNode.start();
}

document.getElementById("audioBtn").addEventListener("click", async () => {
  if (audioOn) return;
  initAudio();
  audioOn = true;
  document.getElementById("audioBtn").remove();
});

/* =========================
   TRIAL STATE
========================= */
let active = false;
let t0 = 0;
let rafId = 0;

let hitCount = 0;
let missCount = 0;
let rtHistory = [];

/* Degenerate spiral drift (sub-perceptual): extremely small angular drift */
let phase = 0; // radians
const PHASE_DRIFT = 0.00035; // tiny; not legible as rotation

/* Visual parameters (minimal) */
const OFFWHITE = { r: 236, g: 236, b: 230 }; // off-white on near-black
const BASE_WIDTH = 3.0;       // px at onset
const MIN_ALPHA = 0.003;      // fade-to-infinity floor (effectively gone)

/* =========================
   INPUT: TAP ONLY WHEN ACTIVE
========================= */
document.body.addEventListener("pointerdown", () => {
  if (!active) return;

  const rt = performance.now() - t0;
  rtHistory.push(rt);
  if (rtHistory.length > RT_HISTORY) rtHistory.shift();

  // hit
  hitCount++;
  missCount = 0;

  if (canAdapt() && hitCount >= HITS_TO_TIGHTEN) {
    REACTION_WINDOW_MS = clamp(REACTION_WINDOW_MS - STEP_MS, MIN_WINDOW_MS, MAX_WINDOW_MS);
    hitCount = 0;
    persist();
  }

  endTrial(); // immediately clear on tap (no extra stimuli)
});

/* =========================
   CALM GATING (NO RHYTHM CHANGE)
========================= */
function stdDev(arr) {
  const mean = arr.reduce((a,b)=>a+b,0) / arr.length;
  const v = arr.reduce((a,b)=>a + (b-mean)*(b-mean),0) / arr.length;
  return Math.sqrt(v);
}

function canAdapt() {
  if (rtHistory.length < RT_HISTORY) return false;
  if (stdDev(rtHistory) > MAX_RT_STD_MS) return false;
  return true;
}

/* =========================
   ENVELOPE: FADE-TO-INFINITY
   alpha(t) = exp(-k t), with alpha(T) ~ MIN_ALPHA
========================= */
function envelopeAlpha(elapsedMs, windowMs) {
  const T = Math.max(1, windowMs);
  const t = clamp(elapsedMs, 0, T);
  // Solve exp(-k*T) = MIN_ALPHA  =>  k = -ln(MIN_ALPHA)/T
  const k = -Math.log(MIN_ALPHA) / T;
  return Math.exp(-k * t);
}

function envelopeWidth(alpha) {
  // Width decays with alpha, rounded ends stay rounded
  return Math.max(0.2, BASE_WIDTH * Math.pow(alpha, 0.65));
}

/* =========================
   RENDER: ONE FAINT LINE, ROUNDED ENDS
   Symbolic layer = emergence → decay → absence (no labels).
========================= */
function render() {
  const now = performance.now();
  const elapsed = now - t0;

  clearField();

  // Envelope over the (adaptive) reaction window
  const a = envelopeAlpha(elapsed, REACTION_WINDOW_MS);
  const w = envelopeWidth(a);

  // Sub-perceptual phase drift (degenerate spiral idea without visible rotation)
  phase += PHASE_DRIFT;

  // Keep orientation essentially vertical; add infinitesimal tilt only
  const tilt = Math.sin(phase) * 0.012; // radians (very small)

  // Line geometry
  const cx = side / 2;
  const cy = side / 2;
  const len = side * 0.45;

  // Apply tilt around center
  const dx = Math.sin(tilt) * (len / 2);
  const dy = Math.cos(tilt) * (len / 2);

  // Off-white with alpha
  ctx.save();
  ctx.globalCompositeOperation = "source-over";
  ctx.lineCap = "round";
  ctx.lineWidth = w;
  ctx.strokeStyle = `rgba(${OFFWHITE.r}, ${OFFWHITE.g}, ${OFFWHITE.b}, ${a})`;

  ctx.beginPath();
  ctx.moveTo(cx - dx, cy - dy);
  ctx.lineTo(cx + dx, cy + dy);
  ctx.stroke();
  ctx.restore();

  // Audio mapping: extremely low gain, proportional to alpha (same envelope)
  if (audioOn && gainNode) {
    // Keep it barely there; max gain intentionally tiny
    gainNode.gain.value = 0.02 * a;
  }

  // Window end = miss if no tap happened
  if (elapsed >= REACTION_WINDOW_MS) {
    // miss
    active = false;
    missCount++;
    hitCount = 0;

    if (canAdapt() && missCount >= MISSES_TO_LOOSEN) {
      REACTION_WINDOW_MS = clamp(REACTION_WINDOW_MS + STEP_MS, MIN_WINDOW_MS, MAX_WINDOW_MS);
      missCount = 0;
      persist();
    }

    endTrial();
    return;
  }

  rafId = requestAnimationFrame(render);
}

/* =========================
   TRIAL CONTROL (FIXED RHYTHM)
========================= */
function startTrial() {
  active = true;
  t0 = performance.now();

  // Start render loop
  cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(render);
}

function endTrial() {
  active = false;

  // Stop audio (silence) between trials
  if (audioOn && gainNode) gainNode.gain.value = 0.0;

  cancelAnimationFrame(rafId);
  clearField();

  // Fixed gap (external cadence does not adapt)
  setTimeout(startTrial, GAP_MS);
}

/* =========================
   UTILS
========================= */
function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

/* =========================
   START
========================= */
clearField();
setTimeout(startTrial, START_DELAY_MS);
</script>
</body>
</html>
