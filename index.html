<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Initiation Threshold — Φ (Speed Layer Only)</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #0b0b0b; /* near-black */
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas { display: block; }
  #audioBtn{
    position: fixed;
    right: 10px;
    bottom: 10px;
    padding: 6px 10px;
    font-size: 12px;
    background: rgba(20,20,20,0.9);
    color: rgba(210,210,210,0.55);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 8px;
    opacity: 0.35;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<button id="audioBtn">audio</button>

<script>
/* =========================================================
   Φ: GOVERNED COLLAPSE (SPEED LAYER ONLY)
   - Only adaptive parameter: REACTION_WINDOW_MS
   - External cadence fixed (GAP_MS constant)
   - Calm/stability gating decides if hits/misses may propagate
   - Day-level carryover: subtle persistence of window only
========================================================= */

const STORAGE_KEY = "phi_speedlayer_state_v1";

/* -------------------------
   CONFIG (fixed cadence)
-------------------------- */
const GAP_MS = 1200;                 // fixed external cadence (do not adapt)
let REACTION_WINDOW_MS = 1400;       // ONLY thing that adapts

const MIN_WINDOW = 900;
const MAX_WINDOW = 1800;
const STEP_MS = 50;

/* Φ gating */
const RT_HISTORY = 6;
const MAX_RT_STD = 120;              // ms
const CALM_MISS_WINDOW = 5;          // recent misses threshold
const HIT_THRESHOLD = 5;             // eligible hits to tighten
const MISS_THRESHOLD = 3;            // eligible misses to loosen

/* Visual (minimal) */
const BG = "#0b0b0b";
const OFFWHITE = { r: 245, g: 240, b: 230 }; // off-white
const LINE_LEN_FRAC = 0.82;          // relative to square size
const LINE_W_START = 2.2;            // px (will decay)
const LINE_W_END = 0.35;             // px (asymptote)
const ALPHA_START = 0.22;            // will decay
const ALPHA_END = 0.015;             // fade-to-infinity asymptote
const DRIFT_PER_MS = 0.00000013;     // degenerate drift (tiny)

/* -------------------------
   PERSISTENCE (day-level carryover)
-------------------------- */
function loadState() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY)); }
  catch { return null; }
}
function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({
    REACTION_WINDOW_MS,
    lastSaved: Date.now()
  }));
}
const saved = loadState();
if (saved && typeof saved.REACTION_WINDOW_MS === "number") {
  // tiny soft reset upward so you don't start too tight the next day
  REACTION_WINDOW_MS = clamp(saved.REACTION_WINDOW_MS + 25, MIN_WINDOW, MAX_WINDOW);
}

/* -------------------------
   CANVAS + FIELD (1:1 square)
-------------------------- */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: false });

let W=0, H=0, S=0, ox=0, oy=0;
function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  S = Math.min(W, H);
  ox = (W - S) / 2;
  oy = (H - S) / 2;
}
addEventListener("resize", resize, { passive: true });
resize();

/* -------------------------
   AUDIO (optional, minimal, mapped to visibility)
   - iOS requires a user gesture; button removes itself.
-------------------------- */
let audioOn = false;
let audioCtx, noiseSrc, gainNode, filterNode;

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // white noise buffer
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;

  noiseSrc = audioCtx.createBufferSource();
  noiseSrc.buffer = buffer;
  noiseSrc.loop = true;

  // gentle low-pass so it's not harsh
  filterNode = audioCtx.createBiquadFilter();
  filterNode.type = "lowpass";
  filterNode.frequency.value = 700; // keep it soft

  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0.0; // starts silent; we drive it

  noiseSrc.connect(filterNode).connect(gainNode).connect(audioCtx.destination);
  noiseSrc.start();
}

document.getElementById("audioBtn").onclick = async () => {
  if (audioOn) return;
  initAudio();
  audioOn = true;
  // if suspended, resume
  if (audioCtx && audioCtx.state === "suspended") await audioCtx.resume();
  document.getElementById("audioBtn").remove();
};

/* Smooth audio target */
let audioTarget = 0.0;
function setAudioTarget(v) {
  audioTarget = clamp(v, 0, 0.012); // QUIET (hard cap)
}

/* -------------------------
   Φ STATE
-------------------------- */
let active = false;
let promptStart = 0;

let hitCount = 0;
let missCount = 0;

let rtHistory = [];
let recentMisses = 0;

/* Degenerate drift */
let angle = 0;
let driftDir = 1;

/* -------------------------
   GOVERNANCE (Φ gating)
-------------------------- */
function stdDev(arr) {
  const m = arr.reduce((a,b)=>a+b,0) / arr.length;
  const v = arr.reduce((a,b)=>a + (b-m)**2,0) / arr.length;
  return Math.sqrt(v);
}

function canPropagate() {
  // Φ: do not let signal propagate unless calm/consistent
  if (rtHistory.length < RT_HISTORY) return false;
  if (recentMisses > CALM_MISS_WINDOW) return false;
  if (stdDev(rtHistory) > MAX_RT_STD) return false;
  return true;
}

/* -------------------------
   INPUT
   - Tap only matters if prompt is active
   - No feedback, no score
-------------------------- */
document.body.addEventListener("pointerdown", () => {
  if (!active) return;

  const rt = performance.now() - promptStart;
  rtHistory.push(rt);
  if (rtHistory.length > RT_HISTORY) rtHistory.shift();

  hitCount++;
  missCount = 0;
  recentMisses = Math.max(0, recentMisses - 1);

  // Φ: tightening only when hits are eligible
  if (canPropagate() && hitCount >= HIT_THRESHOLD && REACTION_WINDOW_MS > MIN_WINDOW) {
    REACTION_WINDOW_MS = clamp(REACTION_WINDOW_MS - STEP_MS, MIN_WINDOW, MAX_WINDOW);
    hitCount = 0;
    saveState();
  }

  endPrompt(); // commit ends the prompt (no extra layers)
}, { passive: true });

/* -------------------------
   LOOP (fixed cadence; only window length changes)
-------------------------- */
let rafId = 0;
let timeoutId = 0;

function startPrompt() {
  active = true;
  promptStart = performance.now();
  driftDir *= -1; // subtle alternation
  // run render loop during active
  cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(render);

  // window timeout (ONLY adaptive timing variable)
  clearTimeout(timeoutId);
  timeoutId = setTimeout(() => {
    // miss
    active = false;
    missCount++;
    hitCount = 0;
    recentMisses++;

    // Φ: loosening only when misses are eligible
    if (canPropagate() && missCount >= MISS_THRESHOLD && REACTION_WINDOW_MS < MAX_WINDOW) {
      REACTION_WINDOW_MS = clamp(REACTION_WINDOW_MS + STEP_MS, MIN_WINDOW, MAX_WINDOW);
      missCount = 0;
      saveState();
    }

    endPrompt();
  }, REACTION_WINDOW_MS);
}

function endPrompt() {
  active = false;
  cancelAnimationFrame(rafId);
  clearField();
  setAudioTarget(0.0);
  // fixed gap
  clearTimeout(timeoutId);
  timeoutId = setTimeout(startPrompt, GAP_MS);
}

/* -------------------------
   RENDER (minimal stimulus)
   - 1:1 centered field
   - faint off-white line with rounded caps
   - fade-to-infinity (alpha + width decay)
   - degenerate spiral drift (tiny angle change)
-------------------------- */
function clearField() {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);
}
clearField();

function render(t) {
  if (!active) return;

  const elapsed = performance.now() - promptStart;
  const p = clamp(elapsed / REACTION_WINDOW_MS, 0, 1);

  // Exponential-ish fade to asymptote (never hard-off)
  const alpha = ALPHA_END + (ALPHA_START - ALPHA_END) * Math.exp(-5.0 * p);
  const width = LINE_W_END + (LINE_W_START - LINE_W_END) * Math.exp(-4.0 * p);

  // Degenerate drift: tiny angular movement (sub-perceptual)
  angle += driftDir * DRIFT_PER_MS * (16.7); // approx per frame

  // Clear background
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);

  // Clip to 1:1 square field
  ctx.save();
  ctx.beginPath();
  ctx.rect(ox, oy, S, S);
  ctx.clip();

  // Center + line endpoints (slight rotation around center)
  const cx = ox + S / 2;
  const cy = oy + S / 2;
  const halfLen = (S * LINE_LEN_FRAC) / 2;

  // Base orientation: slightly off vertical/horizontal middle ground
  const baseTheta = Math.PI / 2 + 0.12; // near-vertical but not pure
  const theta = baseTheta + angle;

  const dx = Math.cos(theta) * halfLen;
  const dy = Math.sin(theta) * halfLen;

  // Draw line
  ctx.lineWidth = width;
  ctx.lineCap = "round";
  ctx.strokeStyle = `rgba(${OFFWHITE.r},${OFFWHITE.g},${OFFWHITE.b},${alpha})`;

  ctx.beginPath();
  ctx.moveTo(cx - dx, cy - dy);
  ctx.lineTo(cx + dx, cy + dy);
  ctx.stroke();

  ctx.restore();

  // Audio follows visibility (smoothed)
  if (audioOn && gainNode) {
    // Map alpha to quiet gain (with slight smoothing)
    const target = 0.010 * (alpha / ALPHA_START);
    setAudioTarget(target);
    const g = gainNode.gain.value;
    gainNode.gain.value = g + (audioTarget - g) * 0.06; // slow smoothing
  }

  rafId = requestAnimationFrame(render);
}

/* -------------------------
   HELPERS
-------------------------- */
function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

/* -------------------------
   START
-------------------------- */
setTimeout(startPrompt, 900);
</script>
</body>
</html>
