<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Scalar Drift Instrument</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas { display: block; }
  #audioBtn{
    position: fixed;
    bottom: 22px;
    left: 50%;
    transform: translateX(-50%);
    padding: 14px 18px;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.9);
    font-size: 15px;
    backdrop-filter: blur(8px);
  }
</style>
</head>
<body>

<canvas id="c"></canvas>
<button id="audioBtn">Enable Audio</button>

<script>
/* =========================================================
   CORE (keep simple, bounded, non-rhythmic)
========================================================= */

// tick sampling (slow enough to avoid “beat”, fast enough to feel alive)
const TICK_SECONDS = 1.8;

// visible scalar in [0,1]
let x = 0.5;

// latent probability + hidden binary
let p = 0.5;
const MU_M = 0.46;
const MU_F = 0.54;

// dynamics
const MEAN_PULL = 0.14;
const NOISE_AMPLITUDE = 0.018;
const P_RELAX = 0.002;
const P_JITTER = 0.003;

// visual bounds (never disappear)
const OP_MIN = 0.18;     // asymptotic minimum opacity (non-zero)
const OP_MAX = 0.62;

const W_BASE = 12;       // base width in CSS px
const W_MIN = 0.85;      // *multipliers*
const W_MAX = 1.05;

// slow “carrier drift” (no rhythm; slow asymptotic wandering)
let op = 0.45;
let wMul = 1.0;

const OP_DRIFT = 0.0025;   // per tick tiny wander
const OP_RELAX = 0.004;    // pulls toward mid (prevents extremes)

const W_DRIFT  = 0.0018;   // even smaller than opacity
const W_RELAX  = 0.004;

// subtle acknowledgement (NOT a pulse rhythm; just a micro “breath”)
let micro = 0;
const MICRO_ADD = 0.10;
const MICRO_DECAY = 0.12;

/* =========================================================
   CANVAS
========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  canvas.width = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
addEventListener("resize", resize);
resize();

/* =========================================================
   AUDIO (presence-only; no frequency encoding)
========================================================= */
let audioCtx, noiseNode, gainNode;
let audioEnabled = false;

function initAudio(){
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i=0;i<data.length;i++) data[i] = Math.random()*2 - 1;

  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = buffer;
  noiseNode.loop = true;

  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0;

  noiseNode.connect(gainNode).connect(audioCtx.destination);
  noiseNode.start();

  // gentle fade-in to a near-threshold bed
  gainNode.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 1.2);
}

document.getElementById("audioBtn").onclick = () => {
  if (!audioEnabled){
    initAudio();
    audioEnabled = true;
    document.getElementById("audioBtn").remove();
  }
};

/* =========================================================
   UTILS
========================================================= */
const clamp01 = v => Math.max(0, Math.min(1, v));
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

// approx gaussian
function randn(){
  let s = 0;
  for (let i=0;i<6;i++) s += Math.random();
  return (s - 3) / 1.22;
}

/* =========================================================
   TICK UPDATE
========================================================= */
let lastTick = performance.now();

function tick(){
  // drift latent p
  p += (0.5 - p) * P_RELAX;
  p += (Math.random() - 0.5) * P_JITTER;
  p = clamp01(p);

  // sample hidden state
  const isM = Math.random() < p;
  const mu = isM ? MU_M : MU_F;

  // update visible scalar
  x += MEAN_PULL * (mu - x);
  x += NOISE_AMPLITUDE * randn();
  x = clamp01(x);

  // carrier drift (bounded, slow, non-rhythmic)
  const opMid = (OP_MIN + OP_MAX) / 2;
  op += (Math.random() - 0.5) * OP_DRIFT;
  op += (opMid - op) * OP_RELAX;
  op = clamp(op, OP_MIN, OP_MAX);

  const wMid = (W_MIN + W_MAX) / 2;
  wMul += (Math.random() - 0.5) * W_DRIFT;
  wMul += (wMid - wMul) * W_RELAX;
  wMul = clamp(wMul, W_MIN, W_MAX);

  // micro acknowledgement (tiny, decays; not a beat)
  micro = Math.min(1, micro + MICRO_ADD);
}

/* =========================================================
   RENDER
========================================================= */
function draw(){
  const now = performance.now();
  if (now - lastTick >= TICK_SECONDS * 1000){
    tick();
    lastTick += TICK_SECONDS * 1000;
  }

  micro *= (1 - MICRO_DECAY);

  // background fixed (DO NOT fade)
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, innerWidth, innerHeight);

  // geometry
  const barH = innerHeight * 0.65;
  const barTop = (innerHeight - barH) / 2;
  const cx = innerWidth / 2;

  const w = W_BASE * wMul;

  // track (faint)
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = "#fff";
  ctx.fillRect(cx - w/2, barTop, w, barH);

  // fill amount
  const filledH = barH * x;
  const yFillTop = barTop + (barH - filledH);

  // filled bar alpha: bounded + tiny micro “breath”
  const a = clamp(op + micro * 0.08, OP_MIN, OP_MAX);

  // rounded ends: use a rounded-rect path
  ctx.globalAlpha = a;
  ctx.fillStyle = "#fff";
  roundRect(ctx, cx - w/2, yFillTop, w, filledH, Math.min(w/2, 10));
  ctx.fill();

  ctx.globalAlpha = 1;
  requestAnimationFrame(draw);
}

// rounded-rect helper (no external libs)
function roundRect(ctx, x, y, w, h, r){
  r = Math.max(0, Math.min(r, w/2, h/2));
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y,     x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x,     y + h, r);
  ctx.arcTo(x,     y + h, x,     y,     r);
  ctx.arcTo(x,     y,     x + w, y,     r);
  ctx.closePath();
}

draw();
</script>
</body>
</html>
