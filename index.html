<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Initiation Threshold â€” Speed Layer Only</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #0b0b0b;
  overflow: hidden;
  touch-action: manipulation;
}
canvas { display: block; }

#audioBtn {
  position: fixed;
  top: 10px;
  right: 10px;
  padding: 6px 10px;
  font-size: 12px;
  background: rgba(20,20,20,0.55);
  color: rgba(220,220,220,0.55);
  border: 1px solid rgba(255,255,255,0.10);
  border-radius: 10px;
}
</style>
</head>

<body>
<canvas id="c"></canvas>
<button id="audioBtn">audio</button>

<script>
/* =========================
   FIXED STRUCTURE
========================= */
const CADENCE_MS = 2000;
const PROMPT_MS = 70;
const REFRACTORY_MS = 420; // NEW: post-commitment delay (fixed)
const ONSET_JITTER_MS = 40;

/* =========================
   SPEED LAYER (ONLY ADAPTIVE)
========================= */
let REACTION_WINDOW = 420;
const MIN_WINDOW = 180;
const MAX_WINDOW = 650;
const STEP_MS = 15;

const RT_HISTORY = 8;
const CALM_STD_MAX = 55;
const TIGHTEN_HITS = 6;
const LOOSEN_MISSES = 2;

const STORAGE_KEY = "speed_layer_state_v2";

/* =========================
   RESTORE
========================= */
try {
  const s = JSON.parse(localStorage.getItem(STORAGE_KEY));
  if (s?.REACTION_WINDOW) {
    REACTION_WINDOW = Math.min(MAX_WINDOW,
      Math.max(MIN_WINDOW, s.REACTION_WINDOW + 10));
  }
} catch {}

function persist() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({
    REACTION_WINDOW,
    lastSaved: Date.now()
  }));
}

/* =========================
   CANVAS
========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: false });

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* =========================
   AUDIO (OPTIONAL)
========================= */
let audioCtx, noiseNode, gainNode, audioOn = false;

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;

  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = buf;
  noiseNode.loop = true;

  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0.008;

  noiseNode.connect(gainNode).connect(audioCtx.destination);
  noiseNode.start();
}

document.getElementById("audioBtn").onclick = async () => {
  if (audioOn) return;
  initAudio();
  audioOn = true;
  try { await audioCtx.resume(); } catch {}
  document.getElementById("audioBtn").remove();
};

/* =========================
   VISUAL
========================= */
let lineAlpha = 0;
let linePhase = 0;

function draw() {
  ctx.fillStyle = "rgba(11,11,11,0.12)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (lineAlpha > 0.001) {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    linePhase += 0.0004;

    const angle = Math.PI * 0.15 + Math.sin(linePhase) * 0.12;
    const len = Math.min(canvas.width, canvas.height) * 0.7;

    ctx.beginPath();
    ctx.lineCap = "round";
    ctx.lineWidth = 2;
    ctx.strokeStyle = `rgba(235,235,225,${lineAlpha})`;
    ctx.moveTo(
      cx - Math.cos(angle) * len / 2,
      cy - Math.sin(angle) * len / 2
    );
    ctx.lineTo(
      cx + Math.cos(angle) * len / 2,
      cy + Math.sin(angle) * len / 2
    );
    ctx.stroke();

    lineAlpha *= 0.90;
  }

  requestAnimationFrame(draw);
}
draw();

/* =========================
   TRIAL LOGIC
========================= */
let trialOnset = 0;
let deadline = 0;
let accepting = false;
let locked = false;

let rtHistory = [];
let stableHits = 0;
let missStreak = 0;

function stdDev(a) {
  const m = a.reduce((s,v)=>s+v,0)/a.length;
  return Math.sqrt(a.reduce((s,v)=>s+(v-m)**2,0)/a.length);
}

function canTighten() {
  return rtHistory.length >= RT_HISTORY && stdDev(rtHistory) <= CALM_STD_MAX;
}

function scheduleNext() {
  const j = (Math.random()*2-1)*ONSET_JITTER_MS;
  setTimeout(startTrial, CADENCE_MS + j);
}

function startTrial() {
  trialOnset = performance.now();
  deadline = trialOnset + REACTION_WINDOW;
  accepting = true;
  locked = false;

  lineAlpha = 0.10;

  setTimeout(() => {}, PROMPT_MS);

  setTimeout(() => {
    if (!accepting) return;
    accepting = false;
    missStreak++;
    stableHits = 0;

    if (missStreak >= LOOSEN_MISSES) {
      REACTION_WINDOW = Math.min(MAX_WINDOW, REACTION_WINDOW + STEP_MS);
      missStreak = 0;
      persist();
    }

    lockAndSchedule();
  }, REACTION_WINDOW);
}

function lockAndSchedule() {
  locked = true;
  setTimeout(() => {
    locked = false;
    scheduleNext();
  }, REFRACTORY_MS);
}

document.body.addEventListener("pointerdown", () => {
  if (!accepting || locked) return;

  accepting = false;
  const now = performance.now();
  const rt = now - trialOnset;

  rtHistory.push(rt);
  if (rtHistory.length > RT_HISTORY) rtHistory.shift();

  const hit = now <= deadline;

  if (hit) {
    stableHits++;
    missStreak = 0;
  } else {
    missStreak++;
    stableHits = 0;
  }

  if (hit && stableHits >= TIGHTEN_HITS && canTighten()) {
    REACTION_WINDOW = Math.max(MIN_WINDOW, REACTION_WINDOW - STEP_MS);
    stableHits = 0;
    persist();
  }

  if (!hit && missStreak >= LOOSEN_MISSES) {
    REACTION_WINDOW = Math.min(MAX_WINDOW, REACTION_WINDOW + STEP_MS);
    missStreak = 0;
    persist();
  }

  lockAndSchedule();
});

/* =========================
   START
========================= */
setTimeout(startTrial, 1000);
</script>
</body>
</html>
