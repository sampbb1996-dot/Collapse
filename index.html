#!/usr/bin/env python3
"""
resell_collapse.py

Terminal, constraint-first reselling detector.

Invariant:
- Silence is default.
- Output occurs ONLY when an external price forces action.
- No suggestion, no optimisation, no escalation, no learning.

If it prints, you act.
If it does not print, nothing is known.
"""

import feedparser
import sqlite3
import hashlib
import time
import re
from datetime import datetime, timezone
from typing import Optional

# ======================
# USER HARD CONSTRAINTS
# ======================

FEEDS = [
    # Example:
    # "https://www.gumtree.com.au/s-sydney/chairs/k0l3003435r10/rss"
]

MAX_BUY_PRICE = 50      # absolute ceiling, not a heuristic
DB_PATH = "seen.sqlite"
POLL_SECONDS = 300

# ======================
# INTERNALS
# ======================

PRICE_RE = re.compile(r"\$?\s*([0-9]{1,6})")

def extract_price(text: str) -> Optional[int]:
    if not text:
        return None
    m = PRICE_RE.search(text.replace(",", ""))
    return int(m.group(1)) if m else None

def uid(link: str) -> str:
    return hashlib.sha256(link.encode()).hexdigest()[:24]

def utc_now() -> str:
    return datetime.now(timezone.utc).isoformat()

# ======================
# STORAGE (MINIMAL STATE)
# ======================

def init_db(conn):
    conn.execute("""
        CREATE TABLE IF NOT EXISTS seen (
            id TEXT PRIMARY KEY,
            first_seen TEXT NOT NULL
        )
    """)
    conn.commit()

def already_seen(conn, i):
    return conn.execute(
        "SELECT 1 FROM seen WHERE id = ?", (i,)
    ).fetchone() is not None

def mark_seen(conn, i):
    conn.execute(
        "INSERT OR IGNORE INTO seen VALUES (?, ?)",
        (i, utc_now())
    )
    conn.commit()

# ======================
# COLLAPSE CONDITION
# ======================

def forced_buy(price: Optional[int]) -> bool:
    return price is not None and price <= MAX_BUY_PRICE

# ======================
# MAIN LOOP
# ======================

def main():
    if not FEEDS:
        raise RuntimeError("No feeds configured.")

    with sqlite3.connect(DB_PATH) as conn:
        init_db(conn)

        while True:
            for feed_url in FEEDS:
                feed = feedparser.parse(feed_url)

                for entry in feed.entries:
                    link = entry.get("link")
                    if not link:
                        continue

                    i = uid(link)
                    if already_seen(conn, i):
                        continue

                    mark_seen(conn, i)

                    title = entry.get("title", "")
                    summary = entry.get("summary", "")

                    price = extract_price(title) or extract_price(summary)

                    if forced_buy(price):
                        print("\n=== BUY ===")
                        print(f"TITLE: {title}")
                        print(f"PRICE: ${price}")
                        print(f"LINK:  {link}")
                        print("==========\n")

            time.sleep(POLL_SECONDS)

if __name__ == "__main__":
    main()
