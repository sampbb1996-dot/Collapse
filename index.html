<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Initiation Threshold â€” Speed Layer Only</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #070707; /* near-black */
  overflow: hidden;
  touch-action: manipulation;
}

#wrap {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
}

canvas {
  display: block;
}

#audioBtn {
  position: fixed;
  bottom: 10px;
  right: 10px;
  font-size: 12px;
  padding: 6px 10px;
  background: rgba(20,20,20,0.6);
  color: rgba(230,230,230,0.4);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 6px;
  opacity: 0.5;
}
</style>
</head>

<body>
<div id="wrap">
  <canvas id="c"></canvas>
</div>
<button id="audioBtn">audio</button>

<script>
/* ======================================================
   LOCKED DESIGN RULES
   - External cadence fixed
   - Only reaction window adapts
   - No symbols, no scoring, no strategy
====================================================== */

/* =========================
   FIXED RHYTHM
========================= */
const GAP_MS = 1200;
const START_DELAY_MS = 1000;

/* =========================
   SPEED LAYER (ONLY ADAPTIVE PARAM)
========================= */
const STORAGE_KEY = "initiation_speed_layer_v1";

let REACTION_WINDOW_MS = 1400;
const MIN_WINDOW_MS = 850;
const MAX_WINDOW_MS = 1900;

const STEP_MS = 50;
const HITS_TO_TIGHTEN = 5;
const MISSES_TO_LOOSEN = 3;

/* Calm gating */
const RT_HISTORY = 6;
const MAX_RT_STD = 120;

/* =========================
   RESTORE DAY-LEVEL STATE
========================= */
(function restore() {
  try {
    const s = JSON.parse(localStorage.getItem(STORAGE_KEY));
    if (s && typeof s.window === "number") {
      REACTION_WINDOW_MS = clamp(
        s.window + 25, // tiny soft reset
        MIN_WINDOW_MS,
        MAX_WINDOW_MS
      );
    }
  } catch {}
})();

function persist() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      window: REACTION_WINDOW_MS,
      saved: Date.now()
    }));
  } catch {}
}

/* =========================
   CANVAS (1:1 FIELD)
========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: false });

let side = 0;

function resize() {
  const m = 20;
  side = Math.max(200, Math.min(innerWidth, innerHeight) - m * 2);

  canvas.width = side * devicePixelRatio;
  canvas.height = side * devicePixelRatio;
  canvas.style.width = side + "px";
  canvas.style.height = side + "px";

  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  clearField();
}

addEventListener("resize", resize);
resize();

function clearField() {
  ctx.fillStyle = "#0b0b0b";
  ctx.fillRect(0, 0, side, side);
}

/* =========================
   AUDIO (OPTIONAL)
========================= */
let audioCtx, noiseNode, gainNode;
let audioOn = false;

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;

  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = buffer;
  noiseNode.loop = true;

  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0;

  noiseNode.connect(gainNode).connect(audioCtx.destination);
  noiseNode.start();
}

document.getElementById("audioBtn").onclick = () => {
  if (!audioOn) {
    initAudio();
    audioOn = true;
    document.getElementById("audioBtn").remove();
  }
};

/* =========================
   STATE
========================= */
let active = false;
let startTime = 0;
let rafId = 0;

let hitCount = 0;
let missCount = 0;
let rtHistory = [];

/* =========================
   VISUAL PARAMETERS
========================= */
const OFFWHITE = { r: 232, g: 232, b: 226 };
const BASE_WIDTH = 3.0;
const MIN_ALPHA = 0.003;

/* Degenerate spiral (sub-perceptual only) */
let phase = 0;
const PHASE_DRIFT = 0.0003;

/* =========================
   INPUT
========================= */
document.body.addEventListener("pointerdown", () => {
  if (!active) return;

  const rt = performance.now() - startTime;
  rtHistory.push(rt);
  if (rtHistory.length > RT_HISTORY) rtHistory.shift();

  hitCount++;
  missCount = 0;

  if (canAdapt() && hitCount >= HITS_TO_TIGHTEN) {
    REACTION_WINDOW_MS = clamp(
      REACTION_WINDOW_MS - STEP_MS,
      MIN_WINDOW_MS,
      MAX_WINDOW_MS
    );
    hitCount = 0;
    persist();
  }

  endTrial();
});

/* =========================
   CALM GATING
========================= */
function stdDev(arr) {
  const mean = arr.reduce((a,b)=>a+b,0) / arr.length;
  const v = arr.reduce((a,b)=>a + (b-mean)**2,0) / arr.length;
  return Math.sqrt(v);
}

function canAdapt() {
  if (rtHistory.length < RT_HISTORY) return false;
  if (stdDev(rtHistory) > MAX_RT_STD) return false;
  return true;
}

/* =========================
   ENVELOPE
========================= */
function alphaAt(elapsed, windowMs) {
  const k = -Math.log(MIN_ALPHA) / windowMs;
  return Math.exp(-k * elapsed);
}

function widthAt(alpha) {
  return Math.max(0.2, BASE_WIDTH * Math.pow(alpha, 0.65));
}

/* =========================
   RENDER LOOP
========================= */
function render() {
  const now = performance.now();
  const elapsed = now - startTime;

  clearField();

  const alpha = alphaAt(elapsed, REACTION_WINDOW_MS);
  const width = widthAt(alpha);

  phase += PHASE_DRIFT;
  const tilt = Math.sin(phase) * 0.01;

  const cx = side / 2;
  const cy = side / 2;
  const len = side * 0.45;

  const dx = Math.sin(tilt) * (len / 2);
  const dy = Math.cos(tilt) * (len / 2);

  ctx.lineCap = "round";
  ctx.lineWidth = width;
  ctx.strokeStyle = `rgba(${OFFWHITE.r},${OFFWHITE.g},${OFFWHITE.b},${alpha})`;

  ctx.beginPath();
  ctx.moveTo(cx - dx, cy - dy);
  ctx.lineTo(cx + dx, cy + dy);
  ctx.stroke();

  if (audioOn && gainNode) {
    gainNode.gain.value = 0.02 * alpha;
  }

  if (elapsed >= REACTION_WINDOW_MS) {
    missCount++;
    hitCount = 0;

    if (canAdapt() && missCount >= MISSES_TO_LOOSEN) {
      REACTION_WINDOW_MS = clamp(
        REACTION_WINDOW_MS + STEP_MS,
        MIN_WINDOW_MS,
        MAX_WINDOW_MS
      );
      missCount = 0;
      persist();
    }

    endTrial();
    return;
  }

  rafId = requestAnimationFrame(render);
}

/* =========================
   TRIAL CONTROL
========================= */
function startTrial() {
  active = true;
  startTime = performance.now();
  rafId = requestAnimationFrame(render);
}

function endTrial() {
  active = false;
  if (audioOn && gainNode) gainNode.gain.value = 0;
  cancelAnimationFrame(rafId);
  clearField();
  setTimeout(startTrial, GAP_MS);
}

/* =========================
   UTILS
========================= */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

/* =========================
   START
========================= */
clearField();
setTimeout(startTrial, START_DELAY_MS);
</script>
</body>
</html>
